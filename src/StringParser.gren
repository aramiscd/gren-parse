module StringParser exposing
    ( Parser
    , Result
    , string
    , fail
    , succeed
    , skip
    , optional
    , zeroOrMore
    , oneOrMore
    , oneOf
    , sequence
    , map
    , andThen
    , run
    )


{-| Parsing string input

---
---

## Data types

---

@docs Parser

---

@docs Result

---
---

## Basic parsers

---

@docs string

---

@docs fail

---

@docs succeed

---
---

## Combinators

---

@docs skip

---

@docs optional

---

@docs zeroOrMore

---

@docs oneOrMore

---

@docs oneOf

---

@docs sequence

---
---

## Transformations

---

@docs map

---

@docs andThen

---
---

## Execution

---

@docs run

-}


{-| Parser
-}
type alias Parser a =
    String -> Maybe ( Result a )


{-| Parse result
-}
type alias Result a =
    { backlog : String      -- Input not yet read
    , values : Array a      -- intermediate results
    }


{-| Parse a fixed string
-}
string : String -> Parser String
string match input =
    if
        String.startsWith match input
    then
        Just
            { backlog = String.dropFirst ( String.count match ) input
            , values = [ match ]
            }
    else
        Nothing


{-| Always fail
-}
fail : Parser a
fail input = Nothing


{-| Always succeed and produce a fixed list of values
-}
succeed : Array a -> Parser a
succeed values input =
    Just { backlog = input, values = values }


{-| Apply a parser and discard the result
-}
skip : Parser a -> Parser a
skip parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> Just { result | values = [] }


{-| Apply a parser if possible
-}
optional : Parser a -> Parser a
optional parse input =
    when parse input is
        Nothing -> Just { backlog = input, values = [] }
        Just result -> Just result


{-| Apply a parser as often as possible
-}
zeroOrMore : Parser a -> Parser a
zeroOrMore parse input =
    Just <| zeroOrMoreHelper parse { backlog = input, values = [] }


{-| Apply a parser as often as possible, but at least once
-}
oneOrMore : Parser a -> Parser a
oneOrMore parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> Just ( zeroOrMoreHelper parse result )


{-| Apply the first successful parser from a list of parsers
-}
oneOf : Array ( Parser a ) -> Parser a
oneOf parsers input =
    oneOfHelper parsers { backlog = input, values = [] }


{-| Apply several parsers in succession
-}
sequence : Array ( Parser a ) -> Parser a
sequence parsers input =
    sequenceHelper parsers { backlog = input, values = [] }


{-| Transform the parsed values
-}
map : ( Array a -> Array b ) -> Parser a -> Parser b
map f parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> Just { backlog = result.backlog, values = f result.values }


{-| Transform the result of a parser
-}
andThen : ( Result a -> Maybe ( Result b ) ) -> Parser a -> Parser b
andThen f parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> f result


{-| Apply a parser and produce a final result
-}
run : Parser a -> String -> Maybe a
run parse input =
    when parse input is
        Just { backlog = "", values = [ value ] } -> Just value
        _ -> Nothing



-- Internal


zeroOrMoreHelper : Parser a -> Result a -> Result a
zeroOrMoreHelper parse acc =
    when parse acc.backlog is
        Nothing -> acc
        Just result -> zeroOrMoreHelper parse { backlog = result.backlog, values = acc.values ++ result.values }


oneOfHelper : Array ( Parser a ) -> Result a -> Maybe ( Result a )
oneOfHelper parsers acc =
    when Array.popFirst parsers is
        Nothing -> Nothing
        Just { first, rest } ->
            when first acc.backlog is
                Nothing -> oneOfHelper rest acc
                Just result -> Just result


sequenceHelper : Array ( Parser a ) -> Result a -> Maybe ( Result a )
sequenceHelper parsers acc =
    when Array.popFirst parsers is
        Nothing -> Just acc
        Just { first, rest } ->
            when first acc.backlog is
                Nothing -> Nothing
                Just { backlog, values } -> sequenceHelper rest { backlog = backlog, values = acc.values ++ values }
