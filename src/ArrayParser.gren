module ArrayParser exposing
    ( Parser
    , Result
    , array
    , fail
    , succeed
    , skip
    , optional
    , zeroOrMore
    , oneOrMore
    , accumulate
    , oneOf
    , sequence
    , map
    , andThen
    , run
    )


{-| Parsing of tokenized input

---
---

## Data types

---

@docs Parser

---

@docs Result

---
---

## Basic parsers

---

@docs array

---

@docs fail

---

@docs succeed

---
---

## Combinators

---

@docs skip

---

@docs optional

---

@docs zeroOrMore

---

@docs oneOrMore

---

@docs oneOf

---

@docs sequence

---
---

## Transformations

---

@docs map

---

@docs andThen

---
---

## Execution

---

@docs run

-}

import Array.Extra as Array


{-| Parser
-}
type alias Parser src dst =
    Array src -> Maybe ( Result src dst )


{-| Parse result
-}
type alias Result src dst =
    { backlog : Array src   -- Input not yet read
    , values  : Array dst   -- intermediate results
    }


{-| Parse a fixed array
-}
array : Array a -> Parser a a
array match input =
    if
        Array.startsWith match input
    then
        Just
            { backlog = Array.dropFirst ( Array.length match ) input
            , values = match
            }
    else
        Nothing


{-| Always fail
-}
fail : Parser src dst
fail input = Nothing


{-| Always succeed and produce a fixed list of values
-}
succeed : Array dst -> Parser src dst
succeed values input =
    Just { backlog = input, values = values }


{-| Apply a parser and discard the result
-}
skip : Parser src dst -> Parser src dst
skip parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> Just { backlog = result.backlog, values = [] }


{-| Apply a parser if possible
-}
optional : Parser src dst -> Parser src dst
optional parse input =
    when parse input is
        Nothing -> Just { backlog = input, values = [] }
        Just result -> Just result


{-| Apply a parser as often as possible
-}
zeroOrMore : Parser src dst -> Parser src dst
zeroOrMore parse input =
    Just ( accumulate parse { backlog = input, values = [] } )


{-| Apply a parser as often as possible, but at least once
-}
oneOrMore : Parser src dst -> Parser src dst
oneOrMore parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> Just ( accumulate parse result )


{-| Accumulate parsed values from a parse backlog in a result structure
-}
accumulate : Parser src dst -> Result src dst -> Result src dst
accumulate parse acc =
    when parse acc.backlog is
        Nothing -> acc
        Just result -> accumulate parse { backlog = result.backlog, values = acc.values ++ result.values }


{-| Apply the first successful parser from a list of parsers
-}
oneOf : Array ( Parser src dst ) -> Parser src dst
oneOf parsers input =
    oneOfHelper parsers { backlog = input, values = [] }


{-| Apply several parsers in succession
-}
sequence : Array ( Parser src dst ) -> Parser src dst
sequence parsers input =
    sequenceHelper parsers { backlog = input, values = [] }


{-| Transform the parsed values
-}
map : ( Array dst1 -> Array dst2 ) -> Parser src dst1 -> Parser src dst2
map f parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> Just { backlog = result.backlog, values = f result.values }


{-| Transform the result of a parser
-}
andThen : ( Result src dst1 -> Maybe ( Result src dst2 ) ) -> Parser src dst1 -> Parser src dst2
andThen f parse input =
    when parse input is
        Nothing -> Nothing
        Just result -> f result


{-| Apply a parser and produce a final result
-}
run : Parser src dst -> Array src -> Maybe dst
run parse input =
    when parse input is
        Just { backlog = [], values = [ value ] } -> Just value
        _ -> Nothing



-- Internal


oneOfHelper : Array ( Parser src dst ) -> Result src dst -> Maybe ( Result src dst )
oneOfHelper parsers acc =
    when Array.popFirst parsers is
        Nothing -> Nothing
        Just { first, rest } ->
            when first acc.backlog is
                Nothing -> oneOfHelper rest acc
                Just result -> Just result


sequenceHelper : Array ( Parser src dst ) -> Result src dst -> Maybe ( Result src dst )
sequenceHelper parsers acc =
    when Array.popFirst parsers is
        Nothing -> Just acc
        Just { first, rest } ->
            when first acc.backlog is
                Nothing -> Nothing
                Just { backlog, values } -> sequenceHelper rest { backlog = backlog, values = acc.values ++ values }
